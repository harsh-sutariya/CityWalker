#!/usr/bin/env python3
"""
Visualize Precomputed Depth Maps

This script loads and visualizes depth maps generated by the preprocessing pipeline.
Useful for verifying depth quality and understanding the data.

Usage:
    python scripts/visualize_depth.py --depth_dir /vast/hs5580/data/citywalker/depths --video_dir dataset/citywalk_2min/videos
    python scripts/visualize_depth.py --depth_file /vast/hs5580/data/citywalker/depths/video_001_depth.npy --video_file dataset/citywalk_2min/videos/video_001.mp4
"""

import sys
import os
from pathlib import Path

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent))

import argparse
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.colors import Normalize
import cv2
from decord import VideoReader, cpu
from tqdm import tqdm
import random


def parse_args():
    parser = argparse.ArgumentParser(description='Visualize precomputed depth maps')
    
    # Option 1: Visualize specific file
    parser.add_argument('--depth_file', type=str, help='Path to specific depth .npy file')
    parser.add_argument('--video_file', type=str, help='Path to corresponding video file')
    
    # Option 2: Browse directory
    parser.add_argument('--depth_dir', type=str, help='Directory containing depth .npy files')
    parser.add_argument('--video_dir', type=str, help='Directory containing video files')
    
    # Visualization options
    parser.add_argument('--num_samples', type=int, default=5, help='Number of random videos to visualize')
    parser.add_argument('--frames_per_video', type=int, default=3, help='Number of frames to show per video')
    parser.add_argument('--max_depth', type=float, default=20.0, help='Maximum depth for colormap')
    parser.add_argument('--save_dir', type=str, default='depth_visualizations', help='Directory to save visualizations')
    parser.add_argument('--dpi', type=int, default=100, help='DPI for saved images')
    
    return parser.parse_args()


def load_depth_and_video(depth_file, video_file, target_fps=1, video_fps=30):
    """Load depth array and corresponding video frames."""
    
    # Load depth
    depth_data = np.load(depth_file)  # (T, H, W)
    print(f"Depth shape: {depth_data.shape}")
    print(f"Depth range: {depth_data.min():.2f}m - {depth_data.max():.2f}m")
    print(f"Mean depth: {depth_data.mean():.2f}m")
    
    # Load video
    video_reader = VideoReader(video_file, ctx=cpu(0))
    num_frames = len(video_reader)
    
    # Compute frame indices at target FPS (same as preprocessing)
    frame_multiplier = video_fps // target_fps
    frame_indices = list(range(0, num_frames, frame_multiplier))
    
    # Load frames
    frames = video_reader.get_batch(frame_indices[:len(depth_data)]).asnumpy()
    
    print(f"Video frames shape: {frames.shape}")
    print(f"Loaded {len(frames)} frames matching {len(depth_data)} depth maps")
    
    return depth_data, frames


def create_depth_colormap(depth, max_depth=20.0, colormap='plasma'):
    """Convert depth array to colored visualization."""
    
    # Normalize depth to [0, 1]
    depth_norm = np.clip(depth / max_depth, 0, 1)
    
    # Apply colormap
    cmap = cm.get_cmap(colormap)
    depth_colored = cmap(depth_norm)
    
    # Convert to uint8 RGB
    depth_colored = (depth_colored[:, :, :3] * 255).astype(np.uint8)
    
    return depth_colored


def visualize_single_frame(rgb_frame, depth_frame, max_depth=20.0, title="Frame"):
    """Create side-by-side visualization of RGB and depth."""
    
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))
    
    # RGB frame
    axes[0].imshow(rgb_frame)
    axes[0].set_title('RGB Frame')
    axes[0].axis('off')
    
    # Depth (grayscale)
    depth_display = np.clip(depth_frame, 0, max_depth)
    im1 = axes[1].imshow(depth_display, cmap='plasma', vmin=0, vmax=max_depth)
    axes[1].set_title('Depth Map')
    axes[1].axis('off')
    plt.colorbar(im1, ax=axes[1], label='Depth (m)', shrink=0.8)
    
    # Depth histogram
    valid_depth = depth_frame[depth_frame > 0.1]  # Filter out invalid depths
    axes[2].hist(valid_depth.flatten(), bins=50, alpha=0.7, color='blue', edgecolor='black')
    axes[2].set_xlabel('Depth (m)')
    axes[2].set_ylabel('Pixel Count')
    axes[2].set_title('Depth Distribution')
    axes[2].grid(True, alpha=0.3)
    
    plt.suptitle(title, fontsize=16)
    plt.tight_layout()
    
    return fig


def visualize_video_sequence(depth_data, frames, video_name, max_depth=20.0, num_frames=3):
    """Visualize a sequence of frames from a video."""
    
    T = len(depth_data)
    
    # Select frames to visualize
    if num_frames >= T:
        frame_indices = list(range(T))
    else:
        # Evenly spaced frames
        frame_indices = np.linspace(0, T-1, num_frames, dtype=int)
    
    print(f"Visualizing frames: {frame_indices} from {T} total frames")
    
    # Create subplots
    fig, axes = plt.subplots(2, len(frame_indices), figsize=(5*len(frame_indices), 8))
    if len(frame_indices) == 1:
        axes = axes.reshape(2, 1)
    
    for i, frame_idx in enumerate(frame_indices):
        rgb_frame = frames[frame_idx]
        depth_frame = depth_data[frame_idx]
        
        # RGB
        axes[0, i].imshow(rgb_frame)
        axes[0, i].set_title(f'RGB Frame {frame_idx}')
        axes[0, i].axis('off')
        
        # Depth
        depth_display = np.clip(depth_frame, 0, max_depth)
        im = axes[1, i].imshow(depth_display, cmap='plasma', vmin=0, vmax=max_depth)
        axes[1, i].set_title(f'Depth Frame {frame_idx}')
        axes[1, i].axis('off')
        
        # Add colorbar to last depth plot
        if i == len(frame_indices) - 1:
            plt.colorbar(im, ax=axes[1, i], label='Depth (m)', shrink=0.8)
    
    plt.suptitle(f'Video: {video_name}', fontsize=16)
    plt.tight_layout()
    
    return fig


def analyze_depth_statistics(depth_dir):
    """Analyze statistics across all depth files."""
    
    depth_files = sorted([f for f in os.listdir(depth_dir) if f.endswith('_depth.npy')])
    
    print(f"\nðŸ“Š Analyzing {len(depth_files)} depth files...")
    
    all_stats = {
        'min_depths': [],
        'max_depths': [],
        'mean_depths': [],
        'std_depths': [],
        'valid_ratios': []
    }
    
    for depth_file in tqdm(depth_files[:100], desc="Analyzing depths"):  # Sample first 100
        depth_path = os.path.join(depth_dir, depth_file)
        depth_data = np.load(depth_path)
        
        # Compute statistics
        valid_mask = (depth_data > 0.1) & (depth_data < 100.0)
        valid_depths = depth_data[valid_mask]
        
        if len(valid_depths) > 0:
            all_stats['min_depths'].append(valid_depths.min())
            all_stats['max_depths'].append(valid_depths.max())
            all_stats['mean_depths'].append(valid_depths.mean())
            all_stats['std_depths'].append(valid_depths.std())
            all_stats['valid_ratios'].append(valid_mask.mean())
    
    # Print summary statistics
    print("\n" + "="*60)
    print("DEPTH STATISTICS SUMMARY")
    print("="*60)
    print(f"Files analyzed: {len(all_stats['min_depths'])}")
    print(f"Min depth across all: {np.min(all_stats['min_depths']):.2f}m")
    print(f"Max depth across all: {np.max(all_stats['max_depths']):.2f}m")
    print(f"Average mean depth: {np.mean(all_stats['mean_depths']):.2f} Â± {np.std(all_stats['mean_depths']):.2f}m")
    print(f"Average valid ratio: {np.mean(all_stats['valid_ratios']):.1%}")
    print("="*60)
    
    # Create summary plot
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))
    
    axes[0, 0].hist(all_stats['mean_depths'], bins=30, alpha=0.7, color='blue')
    axes[0, 0].set_xlabel('Mean Depth (m)')
    axes[0, 0].set_ylabel('Count')
    axes[0, 0].set_title('Distribution of Mean Depths')
    axes[0, 0].grid(True, alpha=0.3)
    
    axes[0, 1].hist(all_stats['max_depths'], bins=30, alpha=0.7, color='red')
    axes[0, 1].set_xlabel('Max Depth (m)')
    axes[0, 1].set_ylabel('Count')
    axes[0, 1].set_title('Distribution of Max Depths')
    axes[0, 1].grid(True, alpha=0.3)
    
    axes[1, 0].hist(all_stats['std_depths'], bins=30, alpha=0.7, color='green')
    axes[1, 0].set_xlabel('Depth Std Dev (m)')
    axes[1, 0].set_ylabel('Count')
    axes[1, 0].set_title('Distribution of Depth Variability')
    axes[1, 0].grid(True, alpha=0.3)
    
    axes[1, 1].hist(all_stats['valid_ratios'], bins=30, alpha=0.7, color='purple')
    axes[1, 1].set_xlabel('Valid Depth Ratio')
    axes[1, 1].set_ylabel('Count')
    axes[1, 1].set_title('Distribution of Valid Depth Ratios')
    axes[1, 1].grid(True, alpha=0.3)
    
    plt.suptitle('Depth Statistics Across Dataset', fontsize=16)
    plt.tight_layout()
    
    return fig, all_stats


def main():
    args = parse_args()
    
    # Create output directory
    os.makedirs(args.save_dir, exist_ok=True)
    
    if args.depth_file and args.video_file:
        # Visualize specific file
        print(f"Visualizing specific files:")
        print(f"  Depth: {args.depth_file}")
        print(f"  Video: {args.video_file}")
        
        depth_data, frames = load_depth_and_video(args.depth_file, args.video_file)
        
        video_name = os.path.basename(args.video_file).replace('.mp4', '')
        fig = visualize_video_sequence(depth_data, frames, video_name, args.max_depth, args.frames_per_video)
        
        output_path = os.path.join(args.save_dir, f'{video_name}_visualization.png')
        fig.savefig(output_path, dpi=args.dpi, bbox_inches='tight')
        print(f"Saved visualization: {output_path}")
        plt.show()
        
    elif args.depth_dir and args.video_dir:
        # Browse directory and visualize random samples
        print(f"Browsing directories:")
        print(f"  Depth: {args.depth_dir}")
        print(f"  Video: {args.video_dir}")
        
        # Get list of depth files
        depth_files = sorted([f for f in os.listdir(args.depth_dir) if f.endswith('_depth.npy')])
        print(f"Found {len(depth_files)} depth files")
        
        # Analyze statistics first
        stats_fig, stats = analyze_depth_statistics(args.depth_dir)
        stats_path = os.path.join(args.save_dir, 'depth_statistics.png')
        stats_fig.savefig(stats_path, dpi=args.dpi, bbox_inches='tight')
        print(f"Saved statistics: {stats_path}")
        
        # Visualize random samples
        sample_files = random.sample(depth_files, min(args.num_samples, len(depth_files)))
        
        for depth_file in sample_files:
            video_file = depth_file.replace('_depth.npy', '.mp4')
            depth_path = os.path.join(args.depth_dir, depth_file)
            video_path = os.path.join(args.video_dir, video_file)
            
            if not os.path.exists(video_path):
                print(f"Warning: Video file not found: {video_path}")
                continue
            
            print(f"\nProcessing: {depth_file}")
            
            try:
                depth_data, frames = load_depth_and_video(depth_path, video_path)
                
                video_name = video_file.replace('.mp4', '')
                fig = visualize_video_sequence(depth_data, frames, video_name, args.max_depth, args.frames_per_video)
                
                output_path = os.path.join(args.save_dir, f'{video_name}_visualization.png')
                fig.savefig(output_path, dpi=args.dpi, bbox_inches='tight')
                print(f"Saved: {output_path}")
                plt.close(fig)  # Close to save memory
                
            except Exception as e:
                print(f"Error processing {depth_file}: {e}")
                continue
        
        print(f"\nâœ… Visualization complete! Check {args.save_dir}/ for results")
        
    else:
        print("Error: Must specify either:")
        print("  1. --depth_file and --video_file for specific visualization")
        print("  2. --depth_dir and --video_dir for batch visualization")


if __name__ == '__main__':
    main()
